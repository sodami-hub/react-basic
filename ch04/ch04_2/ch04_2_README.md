# 04-2 useMemo와 useCallback 훅 이해하기
이 절에서는 데이터를 캐시하는 useMemo와 콜백 함수를 캐시하는 useCallback 훅을 알아본다.

## 🎈리액트 훅의 기본 원리
먼저 변수의 유효 범위(scope)에 관해 알아야 한다. 

### 🕸️상태와 캐시
프로그래밍 분야에서 상태란 용어는 변수의 유효 범위와 무관하게 계속 유지하는 값을 의미한다. 그런데 상태는 한 번 설정되면 이후로는 값을 변경할 수 없는 불변 상태와
아무 때나 값을 변경할 수 있고 계속 유지하는 가변 상태로 나뉜다. 그런데 함수 컴포넌트는 '함수'이므로 블록 범위라는 개념 때문에 상태를 가질 수 없다.
함수 컴포넌트가 상태를 가질 수 있는 유일한 방법은 상태를 담은 변수를 함수 몸통 바깥으로 꺼내어 블록 범위의 영향을 받지 않게 하는 것이다.
이처럼 블록 범위 바깥의 변수를 전역변수라고 한다.  
리액트 훅은 상태를 가질 수 없는 함수 컴포넌트로 하여금 마치 상태를 가진 것처럼 동작할 수 있게 한다. 그리고 이런 개념을 이용하여 캐시를 전역 변수 형태로 만들어서
구현할 수 있다. 캐시는 데이터나 값을 미리 복사해 놓은 임시 저장소를 의미한다. 캐시는 원본 데이터에 접근하는 시간이 오래 걸리거나 
값을 다시 계산하는 시간을 절약하고 싶을 때 주로 사용한다.

### 🕸️캐시 구현하기
src/pages/useOrCreate.ts 파일을 생성하고 코드를 작성한다. 코드에서 cache는 전역 변수이다. 그리고 cache[key]에 설정한 값이 없을 때는
callback 함수를 호출해 cache[key] 에 저장할 값을 생성한 뒤 cache[key]에 저장한다. useOrCreate는 항상 cache[key]에 저장된 값을 반환한다.
여기서 흥미로운 부분은 callback 함수를 단 한 번만 호출한다는 것이다. 이는 앞서 알아본 캐시 개념과 정확히 일치한다.
이제 이함수를 테스트하는 UseOrCreateTest 컴포넌트를 만들어보겠다.

### 🕸️캐시 사용하기
src/pages/UseOrCreateTest.tsx 파일에 코드를 작성한다. 앞서 작성한 useOrCreate 함수를 사용해 head와 body란 이름으로
각기 다른 데이터를 캐시하는 코드이다. 이 덕분에 head와 body는 CreateOrUseTest 컴포넌트가 렌더링될 때마다 반복해서 성생되지 않고
새로운 컴포넌트가 생성될 때 한 번만 생성된다. 따라서 코드를 실행해 보면 중요한 데이터는 캐시를 이용하므로 렌더링이 빠른 것을 느낄수 있다.

### 🕸️캐시와 의존성 목록
리액트 프레임워크 내부에서 관리되는 캐시된 값은 어떤 상황이 일어나면 값을 갱신해 줘야한다. 리액트 훅에서는 캐시를 갱신하게 하는 요소를 의존성이라고 한다.
이러한 의존성으로 구성된 배열을 의존성 목록이라고 한다.  
리액트 프레임워크는 의존성 목록 중 어느 것 하나라도 조건이 충족되면 캐시된 값을 자동으로 갱신하고 해당 컴포넌트를 다시 렌더링하여 반영한다.
만일 이런 캐시 갱신이 필요 없다면, 증 의존성이 전혀 없다면 의존송 목록은 단순히 빈 배열을 사용하면 된다.

### 🕸️함수 컴포넌트와 리액트 훅을 사용하는 이유
리액트는 컴포넌트의 속성값이 변할 때 항상 최신 값이 반영되도록 다시 렌더링한다. 그런데 컴포넌트 내부 로직에서 컴포넌트가 다시 렌더링되는 때는
리액트가 탐지하기 어렵다. 이 때문에 클래스 기반 컴포넌트는 다양한 메서드를 구현해서 렌더링 여부를 판단할 수 있게 한다.  
반면에 함수 컴포넌트에 리액트 훅을 사용하면 리액트 프레임워크가 의존성 목록에서 변한 값이 있는지만 판단하면 되므로 다시 렌더링해야 하는 때를 판단하기 쉽다.
따라서 의미조차 알기 어려운 메서드들을 일일이 구현할 필요가 없어 컴포넌트 개발이 수월해진다.

## 🎈 데이터를 캐시하는 useMemo 훅
react 패키지는 데이터를 캐시하는 용도로 useMemo 훅을 제공한다. 이름에서 'Memo'는 메모이제이션의 줄임말이다.
메모이제이션은 과거에 계산한 값을 반복해서 사용할 때 과거에 계산한 값을 캐시해 두는 방법으로 전체 계산 속도를 높이는 최적화 기법이다.  
useMemo 훅을 사용하는 방법은 다음과 같다. useMemo뿐만 아니라 의존성 목록이 있는 useCallback, useEffect 훅은 의존성에 변화가 생길 때마다
콜백 함수를 자동으로 호출하여 의존성을 반영한다. 보통 콜백 함수는 한 번만 호출되면 충분하므로 의존성 목록은 의존성이 전혀 없음을 의미하는 []로 사용한다.
```
useMemo 훅 사용법
const 캐시된_데이터 = useMemo(콜백_함수, [의존성1, 의존성2, ...])
콜백_함수 =() => 원본_데이터
```
useMemo 훅을 사용하는 타입스크립트 코드를 보면 다음과 같은 형태를 보이는 제네릭 함수이다.
여기서 의존성 목록의 타입인 DependencyList는 읽기 전용 배열이다.
```typescript jsx
function useMemo<T>(factory: () => T, deps: DependencyList): T;
```
앞에서 실습한 캐시 기능을 useMemo 훅으로 대체해서 구현해 보겠다. 먼저 앞서 만들었던 UseOrCreateTest.tsx 파일을 복사해서 Memo.tsx 파일을 만든다.
Memo.tsx 코드는 useOrCreate 함수 대신 useMemo훅 함수로 Memo 컴포넌트를 구현한것이다.
코드에서 head는 내부적으로 headTexts를 사용하므로, headTexts의 내용이 변하면 head도 이에 맞춰 바뀌어야 된다.
즉, head는 headTexts에 의존성이 있으므로 의존성 목록에 넣는다. 마찬가지로 body 역시 users를 의존성 목록에 넣는다.

## 🎈콜백 함수를 캐시하는 useCallback 훅
src/pages/Callback.tsx 파일을 열고 작성한다. 버튼을 클릭하면 onClick 콜백 함수가 호출되도록 구현한 코드이다.  
코드를 실행하고 버튼을 클릭하면 alert 이 호출되어 알림 창이 나타난다. 하지만 구체적으로 어떤 버튼을 클릭했는지 알 수 없다. 이를 해결하고자 고차 함수에 관해 알아보겠다.

### 🕸️고차 함수 사용하기
함수형 언어에서는 함수와 변수를 차별하지 않으므로 함수는 다른 함수의 입력 매개변수나 반환값으로도 사용될 수 있다. 고차 함수는 다른 함수를 반환하는 함수를 의미한다.  
리액트 개발에서 고차함수는 콜백 함수에 어떤 정보를 추가로 전달하려고 할 때 주로 사용한다.  
다음 코드의 onClick은 name 을 매개변수로 받는 함수이지만, '()=> alert(`${name} clicked`)' 이라는 함수를 다시 반환하므로 고차 함수이다.

```typescript jsx
const onClick = useCallback((name:string) => ()=>alert(`${name} clicked`),[])
```
리액트에서 고차 함수를 구현하는 이유는 함수의 타입 불일치를 해결하기 위해서이다. onClick 이벤트 속성은 '()=>void' 타입의 콜백 함수를 설정해야 하므로
다음처럼 콜백 함수 내부에서 필요한 name 변수를 전달할 수 없다.  
그러나 콜백 함수를 다음처럼 고차 함수로 구현하면 onClick이 요구하는 '()=>void' 타입 함수를 반환할 수 있으면서 동시에 함수 몸통이 요구하는 name 또한 전달할 수 있다.
```typescript jsx
(name:string) => () =>alert(`${name} clicked`)
```
앞서 작성한 Callback.tsx 파일을 복사해서 HighOrderCallback.tsx 파일을 만들고 고차 함수를 이용하는 코드로 수정해보겠다.